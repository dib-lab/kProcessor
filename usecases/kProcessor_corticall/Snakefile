pepfile: "project_config.yaml"
configfile: "config.yaml"

kSize=config["kSize"]
references=list(filter(lambda x:x.library=="parent_reference",pep.samples))
references=[(x.sample_name,x.file[0]) for x in references]
references=dict(references)


progny_short=list(filter(lambda x:x.library=="progny_short",pep.samples))
progny_short=[(x.sample_name,x.file) for x in progny_short]
progny_short=dict(progny_short)


dbgs=list(references.keys())+list(progny_short.keys())



def getFile(dict,name):
    return dict[name]


rule all:
    input:
        expand("{sample}.ctx",sample=dbgs),
        expand("{sample}.cleaned.edgesInfered.ctx",sample=progny_short.keys()),
        expand("{sample}.kmc_pre",sample=dbgs),
        expand("{sample}.ref.{ref}.ctp.gz", sample=progny_short.keys(), ref=references.keys()),
        expand("{sample}.se.ctp.gz",sample=progny_short.keys()),
        expand("{sample}.contigs.fa",sample=progny_short.keys()),
        expand("{sample}.unitigs.fa",sample=progny_short.keys()),
        expand("{sample}.kframe.phmap",sample=progny_short.keys())


rule buildParentDBG:
    input:  lambda wildcards: getFile(references,f"{wildcards.sample}")
    output:
        ctx="{sample}.ctx",
        time="{sample}.build.time"
    log: "{sample}.build.log"
    conda: "env.yaml"
    shell:
       	"""
	       /usr/bin/time -v -o {output.time} mccortex {kSize} build -k {kSize} -t 1 --sample {wildcards.sample} -S -m 4G -n 100M  -1 {input} {output.ctx} &> {log}
        """

rule buildPrognyDBG:
    input:  lambda wildcards: getFile(progny_short,f"{wildcards.sample}")
    output:
        ctx="{sample}.ctx",
        time="{sample}.build.time"
    log: "{sample}.build.log"
    conda: "env.yaml"
    shell:
       	"""
	       /usr/bin/time -v -o {output.time} mccortex {kSize} build -k {kSize} -t 3 --sample {wildcards.sample} -S -m 10G -n 150M -2 {input[0]}:{input[1]} {output.ctx} &> {log}
        """

rule cleanPrognyDBG:
    input:  "{sample}.ctx"
    output:
        ctx="{sample}.cleaned.ctx",
        covg_after="{sample}.cleaned.covg_after",
        covg_before="{sample}.cleaned.covg_before",
        len_after="{sample}.cleaned.len_after",
        len_before="{sample}.cleaned.len_before",
        time="{sample}.clean.time"
    log: "{sample}.clean.log"
    conda: "env.yaml"
    shell:
       	"""
	       /usr/bin/time -v -o {output.time} mccortex {kSize} clean -t 1  -m 4G -o {output.ctx} -S  -c {output.covg_before} -C {output.covg_after} -l {output.len_before} -L {output.len_after} {input} &> {log}
        """


rule inferEdgesPrognyDBG:
    input:  "{sample}.cleaned.ctx"
    output:
        ctx="{sample}.cleaned.edgesInfered.ctx",
        time="{sample}.inferedges.time"
    log: "{sample}.inferedges.log"
    conda: "env.yaml"
    shell:
       	"""
	       /usr/bin/time -v -o {output.time} mccortex {kSize} inferedges -m 4G -o {output.ctx} {input} &> {log}
        """

rule threadSEProgny:
    input:
        ctx="{sample}.cleaned.edgesInfered.ctx",
        reads=lambda wildcards: getFile(progny_short,f"{wildcards.sample}")
    output:
        ctp="{sample}.se.ctp.gz",
        time="{sample}.threadSE.time"
    log: "{sample}.threadSE.log"
    conda: "env.yaml"
    shell:
       	"""
       	# arguments meaining:
       	# -W Use two-way gap filling (liberal)
       	# -E Skip extra check after gap bridging
	       /usr/bin/time -v -o {output.time} mccortex {kSize} thread  -t1 -W -E -m 4G -o {output.ctp} -1 {input.reads[0]} -1 {input.reads[1]} {input.ctx} &> {log}
        """

rule threadParentRef:
    input:
        ctx="{sample}.cleaned.edgesInfered.ctx",
        ref= lambda wildcards: getFile(references,f"{wildcards.ref}")
    output:
        ctp="{sample}.ref.{ref}.ctp.gz",
        time="{sample}.{ref}.threadParent.time"
    log: "{sample}.{ref}.threadParent.log"
    conda: "env.yaml"
    shell:
       	"""
       	# arguments meaining:
       	# -W Use two-way gap filling (liberal)
       	# -E Skip extra check after gap bridging
	       /usr/bin/time -v -o {output.time} mccortex {kSize} thread  -t1 -W -E -m 4G -o {output.ctp} -1 {input.ref}  {input.ctx} &> {log}
        """


rule contigs:
    input:
        ctx="{sample}.cleaned.edgesInfered.ctx",
        ctpSE="{sample}.se.ctp.gz",
        ctpRef= expand("{sample}.ref.{ref}.ctp.gz",sample="{sample}",ref=references.keys())
    output:
        contigs="{sample}.contigs.fa",
        time="{sample}.contigs.time"
    log: "{sample}.contigs.log"
    conda: "env.yaml"
    shell:
       	"""
       	# arguments meaining:
       	# -M  Do not use the missing information check
       	# -G Genome size in bases

	    /usr/bin/time -v -o {output.time} mccortex {kSize} contigs  -t1 -m 4G -G 23332839 -M -o {output.contigs} -p {input.ctpRef[0]} -p {input.ctpRef[1]} -p {input.ctpSE} {input.ctx} &> {log}
        """



rule kmcParent:
    input:  lambda wildcards: getFile(references,f"{wildcards.sample}")
    output:
         pre="{sample}.kmc_pre",
         suf="{sample}.kmc_suf",
         time="{sample}.kmc.time"
    threads: 4
    log: "{sample}.kmc.log"
    shell:
       	"""
	/usr/bin/time -v -o {output.time} KMC/bin/kmc -ci1 -t{threads} -k{kSize} -m4 -fm {input} {wildcards.sample}  ./ &> {log}
        """


rule kmcProgny:
    input: lambda wildcards: getFile(progny_short,f"{wildcards.experiment}")
    output:
         pre="{experiment}.kmc_pre",
         suf="{experiment}.kmc_suf",
         time="{experiment}.kmc.time"
    conda:
         "env.yaml"
    threads: 4
    log: "{experiment}.kmc.log"
    shell:
       	"""
    	    echo {input} |tr -s ' ' $'\n' > {wildcards.experiment}.lst
	        /usr/bin/time -v -o {output.time} KMC/bin/kmc -ci1 -cs1000000  -hp  -t{threads} -k{kSize} -m4  @{wildcards.experiment}.lst {wildcards.experiment}  ./ &> {log}

	     #   rm {wildcards.experiment}.lst
        """

rule buildPrognyDBGKprocessor:
    input:  kmc= "{sample}.kmc_pre"
    output:
        ctx="{sample}.kframe.phmap",
        time="{sample}.kprocessor.build.time"
    log: "{sample}.kprocessor.build.log"
    conda: "env.yaml"
    shell:
       	"""
	       /usr/bin/time -v -o {output.time} ../../apps/loadFromKMC {wildcards.sample} PHMAP {wildcards.sample}.kframe  &> {log}
        """


rule bcalmProgny:
    input: lambda wildcards: getFile(progny_short,f"{wildcards.experiment}")
    output:
         unitigs="{experiment}.unitigs.fa",
         time="{experiment}.bcalm.time"
    conda:
         "env.yaml"
    threads: 4
    log: "{experiment}.bcalm.log"
    shell:
       	"""
    	    echo {input} |tr -s ' ' $'\n' > {wildcards.experiment}.lst
    	    /usr/bin/time -v -o {output.time} bcalm -nb-cores {threads} -in {wildcards.experiment}.lst -kmer-size {kSize} -abundance-min 1 -out {wildcards.experiment} &> {log}
        """



# rule kDifferntialExpression:
#     input:
#          sample="sample.kmc_pre",
#          control="control.kmc_pre",
#          transpictome=transpictome
#     output: "kDifferntialExpression.medianChange.lst"
#     log: "kDifferntialExpression.log"
#
#     shell:
#        	"""
# 	./kDifferntialExpression -g {input.transpictome} -s sample -c control -o {output} &> {log}
#         """
#

